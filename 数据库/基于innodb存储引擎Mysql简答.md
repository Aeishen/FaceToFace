# 基于innodb存储引擎Mysql简答

**问题1:为什么一定要设一个主键？**
因为你不设主键的情况下，innodb也会帮你生成一个隐藏列，作为自增主键。所以啦，反正都要生成一个主键，那你还不如自己指定一个主键，在有些情况下，就能显式的用上主键索引，提高查询效率！



**问题2:主键是用自增还是UUID?**
肯定答自增啊。innodb 中的主键是聚簇索引。如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片!
上面那句话看不懂没事，大白话一句就是:用自增插入性能好！



**问题3:自增主键达到最大值了，用完了怎么办?**
自增主键我们用int类型，一般达不到最大值，我们就分库分表了，所以不曾遇见过！



**问题4:主键为什么不推荐有业务含义?**
有如下两个原因

(1)因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。

(2)带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。



**问题5:表示枚举的字段为什么不用enum类型？**
在工作中表示枚举的字段，一般用`tinyint`类型。那为什么不用enum类型呢？下面两个原因
(1)ENUM类型的ORDER BY操作效率低，需要额外操作
(2)如果枚举值是数值，有陷阱
举个例子，表结构如下

```mysql
CREATE TABLE test (foobar ENUM('0', '1', '2'));
```

此时，你执行语句

```mysql
mysql> INSERT INTO test VALUES (1);
```

查询出的结果为

| foobar |
| :----- |
| 0      |

就产生了一个坑爹的结果。
插入语句应该像下面这么写，插入的才是1

```mysql
mysql> INSERT INTO test VALUES (`1`);
```



**问题6:货币字段用什么类型?**
如果货币单位是分，可以用`Int`类型。如果坚持用元，用`Decimal`。
千万不要答`float`和`double`，因为float和double是以二进制存储的，所以有一定的误差。
打个比方，你建一个列如下

```mysql
CREATE TABLE `t` (
  `price` float(10,2) DEFAULT NULL,
) ENGINE=InnoDB DEFAULT CHARSET=utf8
```

然后insert给price列一个数据为`1234567.23`，你会发现显示出来的数据变为`1234567.25`，精度失准！



**问题7:时间字段用什么类型?**
此题无固定答案，应结合自己项目背景来答！把理由讲清楚就行！
(1)`varchar`，如果用varchar类型来存时间，优点在于显示直观。但是坑的地方也是挺多的。比如，插入的数据没有校验，你可能某天就发现一条数据为`2013111`的数据，请问这是代表2013年1月11日，还是2013年11月1日？
其次，做时间比较运算，你需要用`STR_TO_DATE`等函数将其转化为时间类型，你会发现这么写是无法命中索引的。数据量一大，是个坑！

(2)`timestamp`，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间，是无法用`timestamp`类型存储的。
但是它有一个优势，`timestamp`类型是带有时区信息的。一旦你系统中的时区发生改变，例如你修改了时区

```
SET TIME_ZONE = "america/new_york";
```

你会发现，项目中的该字段的值自己会发生变更。这个特性用来做一些国际化大项目，跨时区的应用时，特别注意！

(3)`datetime`，datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。但是它坑的地方在于，他存储的是时间绝对值，不带有时区信息。如果你改变数据库的时区，该项的值不会自己发生变更！

(4)`bigint`，也是8个字节，自己维护一个时间戳，表示范围比`timestamp`大多了，就是要自己维护，不大方便。



**问题8:为什么不直接存储图片、音频、视频等大容量内容?**
我们在实际应用中，都是用`HDFS`来存储文件。然后mysql中，只存文件的存放路径。mysql中有两个字段类型被用来设计存放大容量文件，也就是`text`和`blob`类型。但是，我们在生产中，基本不用这两个类型！
主要原因有如下两点

- (1)Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。导致查询效率缓慢
- (2)`binlog`内容太多。因为你数据内容比较大，就会造成`binlog`内容比较多。大家也知道，主从同步是靠`binlog`进行同步，`binlog`太大了，就会导致主从同步效率问题！

因此，不推荐使用`text`和`blob`类型！



**问题9:字段为什么要定义为NOT NULL?**
从两个角度来答
(1)索引性能不好

> **Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。                                         																—— 出自《高性能mysql第二版》**

(2)查询会出现一些不可预料的结果
这里举一个例子，大家就懂了。假设，表结构如下

```mysql
create table table_2 (
     `id` INT (11) NOT NULL,
    name varchar(20) NOT NULL
)
```

表数据是这样的

| id   | name   |
| :--- | :----- |
| 1    | 孤独烟 |
| 3    | null   |
| 5    | 肥朝   |
| 7    | null   |

你执行语句

```mysql
select count(name) from table_2;
```

你会发现结果为2，但是实际上是有四条数据的！类似的查询问题，其实有很多，不一一列举。
记住，因为null列的存在，会出现很多出人意料的结果，从而浪费开发时间去排查Bug.



## mysql索引

**问题10:一般怎么建索引?**

去my.cnf里配置三个配置

```
打开慢查询日志
slow_query_log=1
慢查询日志存储路径
slow_query_log_file=/var/log/mysql/log-slow-queries.log
SQL执行时间大于3秒，则记录日志
long_query_time=3
```

监控到慢SQL后，就马上开始建索引?
NO,NO,NO….这种时候，应该先考虑你的SQL能不能进行SQL优化。
**例如，当只要一行数据时使用 limit 1**
查询时如果已知会得到一条数据，这种情况下加上 limit 1 会增加性能。因为 mysql 数据库引擎会在找到一条结果停止搜索，而不是继续查询下一条是否符合标准直到所有记录查询完毕。

然而大多数情况下，业务SQL十分复杂，没法优化。所以就要建立索引了。这个时候，参照如下规则建立索引

- (1)索引并非越多越好，大量的索引不仅占用磁盘空间，而且还会影响insert,delete,update等语句的性能
- (2)避免对经常更新的表做更多的索引，并且索引中的列尽可能少；对经常用于查询的字段创建索引，避免添加不必要的索引
- (3)数据量少的表尽量不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果
- (4)在条件表达式中经常用到不同值较多的列上创建索引，在不同值很少的列上不要建立索引。比如性别字段只有“男”“女”俩个值，就无需建立索引。如果建立了索引不但不会提升效率，反而严重减低数据的更新速度
- (5)在频繁进行排序或者分组的列上建立索引，如果排序的列有多个，可以在这些列上建立联合索引。



**问题11:索引的分类?**

从物理存储角度: 聚簇索引和非聚簇索引
从数据结构角度: B+树索引、hash索引、FULLTEXT索引、R-Tree索引
从逻辑角度:

- 主键索引：主键索引是一种特殊的唯一索引，不允许有空值
- 普通索引或者单列索引
- 多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合
- 唯一索引或者非唯一索引
- 空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。



**问题12:如何避免回表查询?什么是索引覆盖?**

当能通过读取索引就可以得到想要的数据，那就不需要回表读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做索引覆盖。

例如此时有一张表`table1`,有一个联合索引(a,b)

执行如下SQL

```mysql
select a,b from table1
```

在索引上就能找到结果，就不用回表去查询！
而你执行的是

```mysql
select a,b,c from table2
```

c列在索引上不存在，就需要回表查询。

需要说明的是覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引不存储索引列的值，所以mysql只能用B+ tree索引做覆盖索引。



**问题13:现在有一个列，里头的数据都是唯一的，需要建一个索引，选唯一索引还是普通索引？**

唯一索引！
在《阿里巴巴JAVA开发规范》中有这么一段话

> **【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引**
>
> **说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。**

那好，下一问出现了！
**为什么唯一索引的插入速度比不上普通索引？为什么唯一索引的查找速度比普通索引快？**

这个问题就要从Insert Buffer开始讲起了，在进行非聚簇索引的插入时，先判断插入的索引页是否在内存中。如果在，则直接插入；如果不在，则先放入Insert Buffer 中，然后再以一定频率和情况进行Insert Buffer和原数据页合并(merge)操作。

这么做的优点:能将多个插入合并到一个操作中，就大大提高了非聚簇索引的插入性能。

InnoDB 从 1.0.x 版本开始引入了 Change Buffer，可以算是对 Insert Buffer 的升级。从这个版本开始，InnoDB 存储引擎可以对 insert、delete、update 都进行缓存。

唯一速度的**插入**比普通索引慢的原因就是:

- 唯一索引无法利用Change Buffer
- 普通索引可以利用Change Buffer

于是乎下一问又来了！
**为什么唯一索引的更新不使用 Change Buffer？**

因为唯一索引为了保证唯一性，需要将数据页加载进内存才能判断是否违反唯一性约束。但是，既然数据页都加载到内存了，还不如直接更新内存中的数据页，没有必要再使用Change Buffer。

最后回答一下，唯一索引的**搜索速度**比普通索引快的原因就是:

- 普通索引在找到满足条件的第一条记录后，还需要判断下一条记录，直到第一个不满足条件的记录出现。
- 唯一索引在找到满足条件的第一条记录后，直接返回，不用判断下一条记录了。



**问题14:mysql索引是什么结构的？用红黑树可以么?**

这个妥妥答最常见的B+ Tree。
AVL树和红黑树基本都是存储在内存中才会使用的数据结构。在大规模数据数据存储的时候，显然不能将全部数据全部加载进内存，因此如果采用红黑树，就会造成频繁IO，效率低下。

那为啥不用B Tree,而选择B+ tree呢？
这就需要贴一下经典的两张图。B tree是长下面这样的

<img src="D:\UserProfiles\aeishenlin\Desktop\简答题\数据库\图片\基于innodb存储引擎Mysql简答\b树.jpg" style="zoom:80%;" />


注意一下B tree的两个明显特点

- 树内存储数据
- 叶子节点上无链表

而B+ tree长下面这样的

![](D:\UserProfiles\aeishenlin\Desktop\简答题\数据库\图片\基于innodb存储引擎Mysql简答\b+树.jpg)

注意一下B+ tree的两个明显特点

- 数据只出现在叶子节点
- 所有叶子节点增加了一个链指针

接下来就可以开始编了～～比如数据库索引采用B+ tree的主要原因是B Tree在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+ tree应运而生。B+ tree只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，如果使用B Tree，则需要做局部的中序遍历，可能要跨层访问，效率太慢。

提示，我下一问就是:
你刚才说了这么多B tree不行，那你知道为啥Mongodb用B Tree当索引，而不用B+ Tree么？
(从关系数据库和非关系数据库的区别角度去答，不拓展了！仔细想想，在Mongodb里表示二者的关系，你会怎么处理!)

